package checkers.inference.model;

import java.util.HashSet;
import java.util.List;
import java.util.Set;
import org.checkerframework.framework.source.Result;
import org.checkerframework.framework.source.SourceChecker;
import org.checkerframework.framework.type.QualifierHierarchy;
import org.checkerframework.framework.type.VisitorState;
import org.checkerframework.javacutil.ErrorReporter;
import checkers.inference.InferenceAnnotatedTypeFactory;
import checkers.inference.VariableAnnotator;
import checkers.inference.util.ConstraintVerifier;

/**
 * Constraint manager holds constraints that are generated by InferenceVisitor.
 *
 * @author mcarthur
 *
 */
public class ConstraintManager {

    private boolean ignoreConstraints = false;

    private final Set<Constraint> constraints = new HashSet<Constraint>();

    private InferenceAnnotatedTypeFactory inferenceTypeFactory;

    private SourceChecker checker;

    private QualifierHierarchy realQualHierarchy;

    private VisitorState visitorState;

    private ConstraintVerifier constraintVerifier;

    public void init(InferenceAnnotatedTypeFactory inferenceTypeFactory) {
        this.inferenceTypeFactory = inferenceTypeFactory;
        this.realQualHierarchy = inferenceTypeFactory.getRealQualifierHierarchy();
        this.visitorState = inferenceTypeFactory.getVisitorState();
        this.checker = inferenceTypeFactory.getContext().getChecker();
        this.constraintVerifier = new ConstraintVerifier(realQualHierarchy);
    }

    public Set<Constraint> getConstraints() {
        return constraints;
    }

    public ConstraintVerifier getConstraintVerifier() {
        return constraintVerifier;
    }

    /**
     * Adds the given constraint to the constraint set if the ignoreConstraints flag is set to
     * false, and the constraint is not an {@link AlwaysTrueConstraint}. An error is issued if the
     * constraint is an {@link AlwaysFalseConstraint}.
     */
    private void add(Constraint constraint) {
        if (!ignoreConstraints) {
            if (constraint instanceof AlwaysFalseConstraint) {
                ErrorReporter.errorAbort(
                        "Attempting to add an AlwaysFalseConstraint to the constraint set.");
            } else if (!(constraint instanceof AlwaysTrueConstraint)) {
                constraints.add(constraint);
            }
        }
    }

    public void startIgnoringConstraints() {
        ignoreConstraints = true;
    }

    public void stopIgnoringConstraints() {
        ignoreConstraints = false;
    }

    // All createXXXConstraint methods create a (possibly normalized) constraint for the given
    // slots, checking for null arguments. It does not issue errors for unsatisfiable constraints.

    /**
     * Creates a {@link SubtypeConstraint} between the two slots, which may be normalized to
     * {@link AlwaysTrueConstraint}, {@link AlwaysFalseConstraint}, or {@link EqualityConstraint}.
     */
    public Constraint createSubtypeConstraint(Slot subtype, Slot supertype) {
        return SubtypeConstraint.create(realQualHierarchy, constraintVerifier, subtype, supertype,
                getCurrentLocation());
    }

    /**
     * Creates an {@link EqualityConstraint} between the two slots, which may be normalized to
     * {@link AlwaysTrueConstraint} or {@link AlwaysFalseConstraint}.
     */
    public Constraint createEqualityConstraint(Slot first, Slot second) {
        return EqualityConstraint.create(constraintVerifier, first, second, getCurrentLocation());
    }

    /**
     * Creates an {@link InequalityConstraint} between the two slots, which may be normalized to
     * {@link AlwaysTrueConstraint} or {@link AlwaysFalseConstraint}.
     */
    public Constraint createInequalityConstraint(Slot first, Slot second) {
        return InequalityConstraint.create(constraintVerifier, first, second, getCurrentLocation());
    }

    /**
     * Creates a {@link ComparableConstraint} between the two slots, which may be normalized to
     * {@link AlwaysTrueConstraint} or {@link AlwaysFalseConstraint}.
     */
    public Constraint createComparableConstraint(Slot first, Slot second) {
        return ComparableConstraint.create(constraintVerifier, first, second, getCurrentLocation());
    }

    /**
     * Creates a {@link CombineConstraint} between the three slots.
     */
    public Constraint createCombineConstraint(Slot target, Slot decl, Slot result) {
        return CombineConstraint.create(target, decl, result, getCurrentLocation());
    }

    /**
     * Creates a {@link PreferenceConstraint} for the given slots with the given weight.
     */
    public Constraint createPreferenceConstraint(VariableSlot variable, ConstantSlot goal,
            int weight) {
        return PreferenceConstraint.create(variable, goal, weight, getCurrentLocation());
    }

    /**
     * Creates an {@link ExistentialConstraint} for the given slot and lists of constraints.
     */
    public Constraint createExistentialConstraint(Slot slot, List<Constraint> ifExistsConstraints,
            List<Constraint> ifNotExistsConstraints) {
        return ExistentialConstraint.create((VariableSlot) slot, ifExistsConstraints,
                ifNotExistsConstraints, getCurrentLocation());
    }

    // TODO: give location directly in Constraint.create() methods
    private AnnotationLocation getCurrentLocation() {
        if (visitorState.getPath() != null) {
            return VariableAnnotator.treeToLocation(inferenceTypeFactory, visitorState.getPath()
                    .getLeaf());
        } else {
            return AnnotationLocation.MISSING_LOCATION;
        }
    }

    // All addXXXConstraint methods create a (possibly normalized) constraint for the given slots
    // and issues errors for unsatisfiable constraints.

    /**
     * Creates and adds a {@link SubtypeConstraint} between the two slots to the constraint set,
     * which may be normalized to {@link AlwaysTrueConstraint} or {@link EqualityConstraint}. An
     * error is issued if the subtype constraint is always unsatisfiable.
     */
    public void addSubtypeConstraint(Slot subtype, Slot supertype) {
        Constraint constraint = createSubtypeConstraint(subtype, supertype);

        if (constraint instanceof AlwaysFalseConstraint) {
            checker.report(Result.failure("subtype.constraint.unsatisfiable", subtype, supertype),
                    visitorState.getPath().getLeaf());
        }

        add(constraint);
    }

    /**
     * Creates and adds an {@link EqualityConstraint} between the two slots to the constraint set,
     * which may be normalized to {@link AlwaysTrueConstraint}. An error is issued if the equality
     * constraint is always unsatisfiable.
     */
    public void addEqualityConstraint(Slot first, Slot second) {
        Constraint constraint = createEqualityConstraint(first, second);

        if (constraint instanceof AlwaysFalseConstraint) {
            checker.report(Result.failure("equality.constraint.unsatisfiable", first, second),
                    visitorState.getPath().getLeaf());
        }

        add(constraint);
    }

    /**
     * Creates and adds an {@link InequalityConstraint} between the two slots to the constraint set,
     * which may be normalized to {@link AlwaysTrueConstraint}. An error is issued if the inequality
     * constraint is always unsatisfiable.
     */
    public void addInequalityConstraint(Slot first, Slot second) {
        Constraint constraint = createInequalityConstraint(first, second);

        if (constraint instanceof AlwaysFalseConstraint) {
            checker.report(Result.failure("inequality.constraint.unsatisfiable", first, second),
                    visitorState.getPath().getLeaf());
        }

        add(constraint);
    }

    /**
     * Creates and adds a {@link ComparableConstraint} between the two slots to the constraint set,
     * which may be normalized to {@link AlwaysTrueConstraint}. An error is issued if the comparable
     * constraint is always unsatisfiable.
     */
    public void addComparableConstraint(Slot first, Slot second) {
        Constraint constraint = createComparableConstraint(first, second);

        if (constraint instanceof AlwaysFalseConstraint) {
            checker.report(Result.failure("comparable.constraint.unsatisfiable", first, second),
                    visitorState.getPath().getLeaf());
        }

        add(constraint);
    }

    /**
     * Creates and adds a {@link CombineConstraint} to the constraint set.
     */
    public void addCombineConstraint(Slot target, Slot decl, Slot result) {
        add(createCombineConstraint(target, decl, result));
    }

    /**
     * Creates and adds a {@link PreferenceConstraint} to the constraint set.
     */
    public void addPreferenceConstraint(VariableSlot variable, ConstantSlot goal, int weight) {
        add(createPreferenceConstraint(variable, goal, weight));
    }

    /**
     * Creates and adds a {@link ExistentialConstraint} to the constraint set.
     */
    public void addExistentialConstraint(Slot slot, List<Constraint> ifExistsConstraints,
            List<Constraint> ifNotExistsConstraints) {
        add(createExistentialConstraint(slot, ifExistsConstraints, ifNotExistsConstraints));
    }
}
